{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline\n",
    "import torch\n",
    "import numpy as np\n",
    "import timeit\n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# What will we be doing\n",
    "\n",
    "1. Review multivariable calculus\n",
    "2. Compute gradients\n",
    "3. Plot them\n",
    "\n",
    "This time we will be using PyTorch so you'll have a chance to experience the package."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Recall Gradients\n",
    "\n",
    "Let $f(x,y)$ be a function in 2 dimension.\n",
    "The gradient of a scalar function is a {\\bf vector} that contain derivatives in each direction.\n",
    "\n",
    "$$ \\nabla f(x,y)= \\begin{pmatrix} {\\frac {\\partial f}{\\partial x}} \\\\ {\\frac {\\partial f}{\\partial y}} \\end{pmatrix} $$ \n",
    "\n",
    "\n",
    "Example if\n",
    "$$ f(x,y) = \\sin(xy) $$\n",
    "Then\n",
    "$$ \\nabla f(x,y)= \\begin{pmatrix}  y\\cos(xy) \\\\ x\\cos(xy) \\end{pmatrix} $$ \n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Numerical Computation of derivatives\n",
    "\n",
    "We can use the same ideas we used in 1D to compute the gradients of a function. Below is the simple change that is done to differentiate the function in the $x$ direction. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def computeGradients(f,hx,hy):\n",
    "    \n",
    "    dfx = (f[2:,:] - f[0:-2,:])/(2*hx)\n",
    "    dfy = (f[:,2:] - f[:,0:-2])/(2*hy)\n",
    "    \n",
    "    return dfx, dfy"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Testing the gradient\n",
    "\n",
    "We now use a similar trick to test the gradient. This time we use PyTorch. A very useful command in 2D is to constract a grid.\n",
    "Here is the way its done in PyTorch"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "xv, yv = torch.meshgrid([torch.arange(0,5), torch.arange(0,3)])\n",
    "print(xv)\n",
    "print(yv)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "pi = 3.1415926535\n",
    "\n",
    "for i in np.arange(2,10):\n",
    "    n = 2**i\n",
    "    x, y = torch.meshgrid([torch.arange(0,n+2), torch.arange(0,n+2)])\n",
    "\n",
    "    x = x/(n+1)\n",
    "    y = y/(n+1)\n",
    "\n",
    "    hx = 1/(n+1)\n",
    "    hy = 1/(n+1)\n",
    "    \n",
    "    \n",
    "    f      = np.sin(2*pi*x*y)   \n",
    "    dfxTrue = 2*pi*y*np.cos(2*pi*x*y)\n",
    "    dfyTrue = 2*pi*x*np.cos(2*pi*x*y)\n",
    "\n",
    "\n",
    "    dfxComp, dfyComp = computeGradients(f,hx,hy)\n",
    "    \n",
    "    # dont use boundaries\n",
    "    dfxTrue = dfxTrue[1:-1,:]\n",
    "    dfyTrue = dfyTrue[:,1:-1]\n",
    "    \n",
    "\n",
    "    resx = torch.abs(dfxTrue - dfxComp)\n",
    "    resy = torch.abs(dfyTrue - dfyComp)\n",
    "\n",
    "    print(hx,  '      ',   torch.max(resx).item(), hy,  '      ',   torch.max(resy).item())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Class/homeworek assignmets\n",
    "\n",
    "Modify the following code to handle boundary points "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def computeGradientsBC(f,hx,hy):\n",
    "    \n",
    "    n = f.shape\n",
    "    dfx = torch.zeros(n[0],n[1])\n",
    "    dfy = torch.zeros(n[0],n[1])\n",
    "    \n",
    "    dfx[1:-1,:] = (f[2:,:] - f[0:-2,:])/(2*hx)\n",
    "    dfy[:,1:-1] = (f[:,2:] - f[:,0:-2])/(2*hy)\n",
    "    \n",
    "    # Your code here\n",
    "    #dfx[0,:] = \n",
    "    #dfy[-1,:] =\n",
    "    #dfy[:,0] = \n",
    "    #dfy[:,-1] =\n",
    "    \n",
    "    return dfx, dfy"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Class/homeworek assignmets\n",
    "\n",
    "Design a test for the code similar to the one we did in 1D "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Plotting the gradients and visualizing things\n",
    "\n",
    "Finally, we would like to plot and visualize the gradients and the fields. \n",
    "We use the following example to do that"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def peaksFun(x,y):\n",
    "    z =  3*(1-x)**2 * torch.exp(-(x**2) - (y+1)**2) - 10*(x/5 - x**3 - y**5)*torch.exp(-x**2-y**2) - 1/3*torch.exp(-(x+1)**2 - y**2)\n",
    "    \n",
    "    return z"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "n = 32\n",
    "t1 = torch.arange(0,n+2)\n",
    "t2 = torch.arange(0,n+2)\n",
    "x, y = torch.meshgrid([t1, t2])\n",
    "\n",
    "# Convert to single precision\n",
    "x = x.float()\n",
    "y = y.float()\n",
    "\n",
    "x = 6*x/(n+1) - 3\n",
    "y = 6*y/(n+1) - 3\n",
    "\n",
    "z = peaksFun(x,y)\n",
    "\n",
    "# now use matplotlib to plot the function - note we need to convert to numpy\n",
    "Z = z.numpy()\n",
    "ext = [-3 , 3, -3 , 3]\n",
    "plt.imshow(Z,extent=ext)\n",
    "plt.colorbar()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can now compute and plot the gradients of f"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "hx = t1[1]-t1[0]\n",
    "hy = t2[1]-t2[0]\n",
    "fx,fy = computeGradients(z,hx,hy)\n",
    "\n",
    "# Get reid of boundaries\n",
    "fx = fx[:,1:-1]\n",
    "fy = fy[1:-1,:]\n",
    "\n",
    "# Now plot it\n",
    "FX = fx.numpy(); FY = fy.numpy();\n",
    "ext = [-3+hx , 3-hx, -3+hy , 3-hy]\n",
    "\n",
    "fig = plt.figure(figsize=(17, 19))\n",
    "gs =  matplotlib.gridspec.GridSpec(nrows=1, ncols=2)\n",
    "\n",
    "ax0 = fig.add_subplot(gs[0, 0])\n",
    "I1 = ax0.imshow(FX,extent=ext)\n",
    "ax0.set_title('df_dx');\n",
    "fig.colorbar(I1);\n",
    "\n",
    "ax0 = fig.add_subplot(gs[0, 1])\n",
    "I2 = ax0.imshow(FY,extent=ext)\n",
    "ax0.set_title('df_dy');\n",
    "fig.colorbar(I2);"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can have more fun plots. The gradient is a vector so we can plot it at every point"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.gridspec as gridspec\n",
    "\n",
    "w = 3\n",
    "# Convert to numpy and transpose\n",
    "X = x[1:-1,1:-1].t().numpy(); Y = y[1:-1,1:-1].t().numpy()\n",
    "U = fx.t().numpy()\n",
    "V = fy.t().numpy()\n",
    "absGrad = np.sqrt(U**2 + V**2)\n",
    "\n",
    "fig = plt.figure(figsize=(12, 15))\n",
    "gs = gridspec.GridSpec(nrows=3, ncols=2, height_ratios=[1, 1, 2])\n",
    "\n",
    "#  Varying density along a streamline\n",
    "ax0 = fig.add_subplot(gs[0, 0])\n",
    "ax0.streamplot(X, Y, U, V, density=[0.5, 1])\n",
    "ax0.set_title('Varying Density')\n",
    "\n",
    "# Varying color along a streamline\n",
    "ax1 = fig.add_subplot(gs[0, 1])\n",
    "strm = ax1.streamplot(X, Y, U, V, color=U, linewidth=2, cmap='autumn')\n",
    "fig.colorbar(strm.lines)\n",
    "ax1.set_title('Varying Color')\n",
    "\n",
    "#  Varying line width along a streamline\n",
    "ax2 = fig.add_subplot(gs[1, 0])\n",
    "lw = 5*absGrad / absGrad.max()\n",
    "ax2.streamplot(X, Y, U, V, density=0.6, color='k', linewidth=lw)\n",
    "ax2.set_title('Varying Line Width')\n",
    "\n",
    "# Controlling the starting points of the streamlines\n",
    "seed_points = np.array([[-2, -1, 0, 1, 2, -1], [-2, -1,  0, 1, 2, 2]])\n",
    "\n",
    "ax3 = fig.add_subplot(gs[1, 1])\n",
    "strm = ax3.streamplot(X, Y, U, V, color=U, linewidth=2,\n",
    "                     cmap='autumn', start_points=seed_points.T)\n",
    "fig.colorbar(strm.lines)\n",
    "ax3.set_title('Controlling Starting Points')\n",
    "\n",
    "# Displaying the starting points with blue symbols.\n",
    "ax3.plot(seed_points[0], seed_points[1], 'bo')\n",
    "ax3.set(xlim=(-w, w), ylim=(-w, w));"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "jupytext": {
   "formats": "ipynb,py:percent",
   "notebook_metadata_filter": "all,-language_info,-toc,-latex_envs"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
